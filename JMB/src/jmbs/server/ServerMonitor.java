package jmbs.server;

import java.util.HashMap;

import jmbs.common.ConnectionInformation;
//TODO make the class thread safe.
/**
 * This class implements a server monitor which will keep in trace of every current established connections to the server.
 * It also contains a security manager which will be able to check if connections are authorized or not.
 * The ServerMonitor logs every connection in a HashMap whose key is a random key generated by the generateKey() method.
 * This key is unique and given to a user when rmi creates a thread on the server. It represents the unique connection id
 * which will be checked every time a users makes a request. If a user which has a wrong key tries to send a request it will 
 * automatically raise a new SercurityException.
 * This class also contains methods which can give the number of connected user or active accounts 
 * 
 * 
 * @author benbabic
 */
public final class ServerMonitor {

	private static ServerMonitor instance = null;
	private HashMap<String,Requests> activeConnections = new HashMap<String,Requests>();
	private HashMap<Integer,String> connectedUsers = new HashMap<Integer,String>();
	//private Security s = new SecurityDAO(new Connect().getConnection());
	private final static int KEY_INTERVAL = 100000;

	private ServerMonitor(){
	}
	
	/**
	 * Adds a new connection in the server monitor.\n
	 * The Request object passed in parameter must be created by a rmi thread.
	 * @param r - request object 
	 */
	public void addConnection(Requests r){
		String cn = r.getConnectionInformations().getConnectionNumber();
		this.activeConnections.put(cn, r);
	}
	
	/**
	 * 
	 * @param key
	 */
	public void endConnection(String key){
		if (this.activeConnections.containsKey(key)) this.activeConnections.remove(key);
	}
	
	/**
	 * Gets the instance of the singleton ServerMonitor.
	 * @return ServerMonitor current instance
	 */
	public final static ServerMonitor getInstance(){
		if (instance == null) {
			synchronized (Configuration.class) {
				if (instance == null)
					instance = new ServerMonitor();
			}
		}
		return instance;
	}
	
	/**
	 * Generates a random key which is not yet used and returns it as a string.
	 * @return String - the new key
	 */
	public String generateKey(){
		int key = 0;
		do{
			key = (int)(Math.random() * (KEY_INTERVAL)) + 1;
		}while (!activeConnections.containsKey(key));
		
		return String.valueOf(key);
	}
	
	/**
	 * Gives the number of connected users
	 * @return the  number of connected users
	 */
	public int getNumberOfActiveAccounts(){
		return connectedUsers.size();
	}
	
	/**
	 * Gives the number of active connections
	 * @return - the number of active connections
	 */
	public int getNumberOfActiveConnections() {
		return activeConnections.size();
	}
	
	/**
	 * Gives the connection informations for a given user.
	 * @param userId - the user id
	 * @return ConnectionInformation - object representing user connection informations
	 */
	public ConnectionInformation getConnectionInformations(int userId){
		return this.getConnectionInformations(this.connectedUsers.get(userId));
	}
	
	/**
	 * Gives the connection informations for a given key.
	 * @param userId - the user id
	 * @return ConnectionInformation - object representing connection informations
	 */
	public ConnectionInformation getConnectionInformations(String key){
		return this.activeConnections.get(key).getConnectionInformations();
	}
	
	/**
	 * Tells if a user is currently connected to the server.
	 * @param userId - the user id
	 * @return true if the connection is active false if not
	 */
	public boolean isAcountActive(int userId){
		return connectedUsers.containsKey(userId);
	}

	/**
	 * Logs a user out.
	 * @param userId - the connection k
	 */
	public void logOut (int userId){
		String key = this.connectedUsers.get(userId);
		this.activeConnections.get(key).getConnectionInformations().logOut();
		this.connectedUsers.remove(userId);
	}
	
	/**
	 * Loggs a user in
	 * @param userId - the user id
	 * @param key - the user ip address
	 */
	public void logIn(int userId, String key) throws SecurityException{
		if (!activeConnections.containsKey(key)) throw new SecurityException("Illegal user trying to connect.\n Try to restart your application \n If the problem presists contact your administator.");
		if (isAcountActive(userId)) logOut(userId);
		this.activeConnections.get(key).getConnectionInformations().logIn(userId);
	}
}
